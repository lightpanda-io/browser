<!DOCTYPE html>
<head>
<script src="../testing.js"></script>
<script>
{
    // Define the custom element BEFORE the HTML is parsed
    window.preParseConnectedCount = 0;

    class PreParseElement extends HTMLElement {
        connectedCallback() {
            window.preParseConnectedCount++;
        }
    }

    customElements.define('pre-parse-element', PreParseElement);
}
</script>
</head>
<body>
<!-- This element is in the HTML and should have connectedCallback invoked -->
<pre-parse-element id="static-element"></pre-parse-element>

<script id="test-static-element">
{
    // connectedCallback should have been called for the element in HTML
    testing.expectEqual(1, window.preParseConnectedCount);

    const el = document.getElementById('static-element');
    testing.expectTrue(el !== null);
    testing.expectEqual('PRE-PARSE-ELEMENT', el.tagName);
}
</script>

<script id="test-programmatic-still-works">
{
    // Reset counter
    window.preParseConnectedCount = 0;

    // This should still work (programmatic creation)
    const el = document.createElement('pre-parse-element');
    testing.expectEqual(0, window.preParseConnectedCount);

    document.body.appendChild(el);
    testing.expectEqual(1, window.preParseConnectedCount);
}
</script>

<script>
{
    window.nestedParentCount = 0;
    window.nestedChildCount = 0;

    class NestedParent extends HTMLElement {
        connectedCallback() {
            window.nestedParentCount++;
        }
    }

    class NestedChild extends HTMLElement {
        connectedCallback() {
            window.nestedChildCount++;
        }
    }

    customElements.define('nested-parent', NestedParent);
    customElements.define('nested-child', NestedChild);
}
</script>

<nested-parent id="parent-element">
    <nested-child id="child-element"></nested-child>
</nested-parent>

<script id="verify-nested">
{
    // Both parent and child should have connectedCallback invoked
    testing.expectEqual(1, window.nestedParentCount);
    testing.expectEqual(1, window.nestedChildCount);

    const parent = document.getElementById('parent-element');
    const child = document.getElementById('child-element');
    testing.expectTrue(parent !== null);
    testing.expectTrue(child !== null);
}
</script>

<script>
{
    // Test attributeChangedCallback for initial attributes during parsing
    window.attrChangedCalls = [];

    class AttrElement extends HTMLElement {
        static get observedAttributes() {
            return ['foo', 'bar'];
        }

        attributeChangedCallback(name, oldValue, newValue) {
            window.attrChangedCalls.push({ name, oldValue, newValue });
        }
    }

    customElements.define('attr-element', AttrElement);
}
</script>

<attr-element foo="value1" bar="value2" ignored="value3"></attr-element>

<script id="verify-attribute-changed">
{
    // attributeChangedCallback should have been called for initial attributes
    testing.expectEqual(2, window.attrChangedCalls.length);

    testing.expectEqual('foo', window.attrChangedCalls[0].name);
    testing.expectEqual(null, window.attrChangedCalls[0].oldValue);
    testing.expectEqual('value1', window.attrChangedCalls[0].newValue);

    testing.expectEqual('bar', window.attrChangedCalls[1].name);
    testing.expectEqual(null, window.attrChangedCalls[1].oldValue);
    testing.expectEqual('value2', window.attrChangedCalls[1].newValue);
}
</script>
</body>
