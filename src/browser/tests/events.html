<!DOCTYPE html>
<script src="testing.js"></script>

<div id=parent><p id=child></p></div>

<script id=addEventListener>
  let child_calls = 0;
  let parent_calls = 0;
  let child = $('#child');
  let parent = $('#parent');

  child.dispatchEvent(new Event('Hello'));
  parent.dispatchEvent(new Event('Hello'));
  testing.expectEqual(0, child_calls);
  testing.expectEqual(0, parent_calls);

  const child_func = (e) => {
    testing.expectEqual('hello', e.type);
    child_calls += 1;
  };
  child.addEventListener('hello', child_func);

  const parent_func = (e) => {
    testing.expectEqual('hello', e.type);
    parent_calls += 1;
  };
  parent.addEventListener('hello', parent_func);

  parent.dispatchEvent(new Event('hello'));
  testing.expectEqual(0, child_calls);
  testing.expectEqual(1, parent_calls);

  parent.dispatchEvent(new Event('Click'));
  testing.expectEqual(0, child_calls);
  testing.expectEqual(1, parent_calls);

  child.dispatchEvent(new Event('hello'));
  testing.expectEqual(1, child_calls);
  testing.expectEqual(1, parent_calls);

  child.dispatchEvent(new Event('hello', {bubbles: true}));
  testing.expectEqual(2, child_calls);
  testing.expectEqual(2, parent_calls);

  child.removeEventListener('other', () => {})
  child.dispatchEvent(new Event('hello', {bubbles: true}));
  testing.expectEqual(3, child_calls);
  testing.expectEqual(3, parent_calls);

  child.removeEventListener('hello', () => {})
  child.dispatchEvent(new Event('hello', {bubbles: true}));
  testing.expectEqual(4, child_calls);
  testing.expectEqual(4, parent_calls);

  // capture is on, still won't remove
  child.removeEventListener('hello', child_func, true)
  child.dispatchEvent(new Event('hello', {bubbles: true}));
  testing.expectEqual(5, child_calls);
  testing.expectEqual(5, parent_calls);

  child.removeEventListener('hello', child_func, false)
  child.dispatchEvent(new Event('hello', {bubbles: true}));
  testing.expectEqual(5, child_calls);
  testing.expectEqual(6, parent_calls);

  // wrong func
  parent.removeEventListener('hello', child_func, false)
  child.dispatchEvent(new Event('hello', {bubbles: true}));
  testing.expectEqual(5, child_calls);
  testing.expectEqual(7, parent_calls);

  parent.removeEventListener('hello', parent_func, false)
  child.dispatchEvent(new Event('hello', {bubbles: true}));
  testing.expectEqual(5, child_calls);
  testing.expectEqual(7, parent_calls);
</script>

<div id=parent2><div id=child2></div></div>
<script id=currentTarget>
  child_calls = 0;
  parent_calls = 0;
  child = $('#child2');
  parent = $('#parent2');

  child.addEventListener('test', (e) => {
    child_calls += 1;
    testing.expectEqual(child, e.target);
    testing.expectEqual(child, e.currentTarget);
  })

  parent.addEventListener('test', (e) => {
    parent_calls += 1;
    testing.expectEqual(child, e.target);
    testing.expectEqual(parent, e.currentTarget);
  });

  child.dispatchEvent(new Event('test', {bubbles: true}));
  testing.expectEqual(1, child_calls);
  testing.expectEqual(1, parent_calls);
</script>

<div id=parent3></div>
<script id=dupe>
  parent_calls = 0;
  parent = $('#parent3');

  const fn1 = function() {
    parent_calls += 100;
  }
  const fn2 = function() {
    parent_calls += 1;
  }
  parent.addEventListener('dupe', fn1);
  parent.addEventListener('dupe', fn1);
  parent.addEventListener('dupe', fn1);
  parent.addEventListener('dupe', fn2);

  parent.dispatchEvent(new Event('dupe'));
  testing.expectEqual(101, parent_calls);
</script>

<div id=parent4><div id=child4></div></div>
<script id=stpoPropagation>
  child_calls = 0;
  parent_calls = 0;
  child = $('#child4');
  parent = $('#parent4');

  parent.addEventListener('propagate', function() {
    parent_calls += 1;
  });

  child.addEventListener('propagate', function(e) {
    child_calls += 1;
    if (child_calls == 2) {
      e.stopPropagation();
    }
  });

  testing.expectEqual(true, child.dispatchEvent(new Event('propagate', {bubbles: true})));
  testing.expectEqual(true, child.dispatchEvent(new Event('propagate', {bubbles: true})));
  testing.expectEqual(true, child.dispatchEvent(new Event('propagate', {bubbles: true})));
  testing.expectEqual(2, parent_calls);
  testing.expectEqual(3, child_calls);
</script>

<div id=grandparent><div id=parent5><div id=child5></div></div></div>
<script id=eventCapture>
  // Test event capture phase
  const order = [];
  const grandparent = $('#grandparent');
  const parent5 = $('#parent5');
  const child5 = $('#child5');

  // Add capture listeners (should fire top-down)
  grandparent.addEventListener('test', () => order.push('grandparent-capture'), true);
  parent5.addEventListener('test', () => order.push('parent-capture'), true);
  child5.addEventListener('test', () => order.push('child-capture'), true);

  // Add bubble listeners (should fire bottom-up)
  grandparent.addEventListener('test', () => order.push('grandparent-bubble'), false);
  parent5.addEventListener('test', () => order.push('parent-bubble'), false);
  child5.addEventListener('test', () => order.push('child-bubble'), false);

  child5.dispatchEvent(new Event('test', {bubbles: true}));

  // Expected order: capture top-down, then target (both), then bubble bottom-up
  testing.expectEqual('grandparent-capture', order[0]);
  testing.expectEqual('parent-capture', order[1]);
  testing.expectEqual('child-capture', order[2]);
  testing.expectEqual('child-bubble', order[3]);
  testing.expectEqual('parent-bubble', order[4]);
  testing.expectEqual('grandparent-bubble', order[5]);
  testing.expectEqual(6, order.length);
</script>

<div id=parent6><div id=child6></div></div>
<script id=eventPhase>
  // Test eventPhase property
  const phases = [];
  const parent6 = $('#parent6');
  const child6 = $('#child6');

  parent6.addEventListener('phase', (e) => {
    phases.push({target: 'parent', phase: e.eventPhase, current: e.currentTarget === parent6});
  }, true);

  child6.addEventListener('phase', (e) => {
    phases.push({target: 'child', phase: e.eventPhase, current: e.currentTarget === child6});
  }, true);

  child6.addEventListener('phase', (e) => {
    phases.push({target: 'child', phase: e.eventPhase, current: e.currentTarget === child6});
  }, false);

  parent6.addEventListener('phase', (e) => {
    phases.push({target: 'parent', phase: e.eventPhase, current: e.currentTarget === parent6});
  }, false);

  child6.dispatchEvent(new Event('phase', {bubbles: true}));

  testing.expectEqual('parent', phases[0].target);
  testing.expectEqual(Event.CAPTURING_PHASE, phases[0].phase);
  testing.expectEqual(true, phases[0].current);

  testing.expectEqual('child', phases[1].target);
  testing.expectEqual(Event.AT_TARGET, phases[1].phase);
  testing.expectEqual(true, phases[1].current);

  testing.expectEqual('child', phases[2].target);
  testing.expectEqual(Event.AT_TARGET, phases[2].phase);
  testing.expectEqual(true, phases[2].current);

  testing.expectEqual('parent', phases[3].target);
  testing.expectEqual(Event.BUBBLING_PHASE, phases[3].phase);
  testing.expectEqual(true, phases[3].current);
</script>

<div id=parent7><div id=child7></div></div>
<script id=stopImmediatePropagation>
  // Test stopImmediatePropagation
  let calls = [];
  const parent7 = $('#parent7');
  const child7 = $('#child7');

  child7.addEventListener('immediate', () => calls.push(1));
  child7.addEventListener('immediate', (e) => {
    calls.push(2);
    e.stopImmediatePropagation();
  });
  child7.addEventListener('immediate', () => calls.push(3));
  parent7.addEventListener('immediate', () => calls.push(4));

  child7.dispatchEvent(new Event('immediate', {bubbles: true}));

  // Should only call the first two listeners, then stop
  testing.expectEqual(1, calls[0]);
  testing.expectEqual(2, calls[1]);
  testing.expectEqual(2, calls.length);
</script>

<div id=parent8><div id=child8></div></div>
<script id=captureStopPropagation>
  // Test that stopPropagation during capture prevents target and bubble
  let capture_calls = [];
  const parent8 = $('#parent8');
  const child8 = $('#child8');

  parent8.addEventListener('capture-stop', (e) => {
    capture_calls.push('parent-capture');
    e.stopPropagation();
  }, true);

  child8.addEventListener('capture-stop', () => capture_calls.push('child-capture'), true);
  child8.addEventListener('capture-stop', () => capture_calls.push('child-bubble'), false);
  parent8.addEventListener('capture-stop', () => capture_calls.push('parent-bubble'), false);

  child8.dispatchEvent(new Event('capture-stop', {bubbles: true}));

  // Should only call parent capture listener
  testing.expectEqual(1, capture_calls.length);
  testing.expectEqual('parent-capture', capture_calls[0]);
</script>

<div id=child9></div>
<script id=nonBubblingNoCapture>
  // Test that non-bubbling events still have capture phase but no bubble phase
  let non_bubble_calls = [];
  const child9 = $('#child9');

  window.addEventListener('nobubble', (e) => {
    non_bubble_calls.push('window-capture');
    testing.expectEqual(Event.CAPTURING_PHASE, e.eventPhase);
  }, true);
  window.addEventListener('nobubble', () => non_bubble_calls.push('window-bubble'), false);
  child9.addEventListener('nobubble', (e) => {
    non_bubble_calls.push('child');
    testing.expectEqual(Event.AT_TARGET, e.eventPhase);
  });

  child9.dispatchEvent(new Event('nobubble', {bubbles: false}));

  // Should call window-capture (during capture phase) and child, but NOT window-bubble
  testing.expectEqual(2, non_bubble_calls.length);
  testing.expectEqual('window-capture', non_bubble_calls[0]);
  testing.expectEqual('child', non_bubble_calls[1]);
</script>

<script id=nullCallback>
  // Test that null callback is handled gracefully
  let nullTestPassed = false;
  window.addEventListener('testnull', null);
  window.removeEventListener('testnull', null);
  nullTestPassed = true;
  testing.expectEqual(true, nullTestPassed);
</script>

<script id=objectCallback>
  // Test object with handleEvent method
  let handleEventCalls = 0;
  const handler = {
    handleEvent: function(e) {
      handleEventCalls += 1;
      testing.expectEqual('customhandler', e.type);
    }
  };

  window.addEventListener('customhandler', handler);
  window.dispatchEvent(new Event('customhandler'));
  testing.expectEqual(1, handleEventCalls);

  window.dispatchEvent(new Event('customhandler'));
  testing.expectEqual(2, handleEventCalls);

  // Remove using the same object
  window.removeEventListener('customhandler', handler);
  window.dispatchEvent(new Event('customhandler'));
  testing.expectEqual(2, handleEventCalls); // Should not increment
</script>

<script id=objectWithoutHandleEvent>
  // Test that registration succeeds even with invalid handlers
  // (Dispatch behavior differs: spec-compliant browsers throw, some ignore)
  const badHandler = { foo: 'bar' };
  let registrationSucceeded = false;
  window.addEventListener('testbad', badHandler);
  registrationSucceeded = true;
  testing.expectEqual(true, registrationSucceeded);

  // Test object with handleEvent that's not a function
  const badHandler2 = { handleEvent: 'not a function' };
  let registrationSucceeded2 = false;
  window.addEventListener('testbad2', badHandler2);
  registrationSucceeded2 = true;
  testing.expectEqual(true, registrationSucceeded2);
</script>

<script id=passiveDetection>
  // Test passive event listener detection pattern (common in polyfills)
  let passiveSupported = false;
  try {
    const opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function() {
        passiveSupported = true;
      }
    });
    window.addEventListener('testpassive', opts, opts);
    window.removeEventListener('testpassive', opts, opts);
  } catch (e) {
    passiveSupported = false;
  }

  testing.expectEqual(true, passiveSupported);
</script>

<div id=reentrancy_test></div>
<script id=removeOtherListenerDuringDispatch>
  // Test that removing another listener during dispatch doesn't crash
  // This reproduces the segfault bug where n.next becomes invalid
  const reentrancy_el = $('#reentrancy_test');
  let reentrancy_calls = [];

  const listener1 = () => {
    reentrancy_calls.push(1);
  };

  const listener2 = () => {
    reentrancy_calls.push(2);
    // Remove listener3 while we're still iterating the listener list
    reentrancy_el.removeEventListener('reentrancy', listener3);
  };

  const listener3 = () => {
    reentrancy_calls.push(3);
  };

  const listener4 = () => {
    reentrancy_calls.push(4);
  };

  reentrancy_el.addEventListener('reentrancy', listener1);
  reentrancy_el.addEventListener('reentrancy', listener2);
  reentrancy_el.addEventListener('reentrancy', listener3);
  reentrancy_el.addEventListener('reentrancy', listener4);

  reentrancy_el.dispatchEvent(new Event('reentrancy'));

  // listener3 was removed during dispatch by listener2, so it should not fire
  // But listener4 should still fire
  testing.expectEqual(1, reentrancy_calls[0]);
  testing.expectEqual(2, reentrancy_calls[1]);
  testing.expectEqual(4, reentrancy_calls[2]);
  testing.expectEqual(3, reentrancy_calls.length);
</script>

<div id=self_remove_test></div>
<script id=removeSelfDuringDispatch>
  // Test that a listener can remove itself during dispatch
  const self_remove_el = $('#self_remove_test');
  let self_remove_calls = [];

  const selfRemovingListener = () => {
    self_remove_calls.push('self');
    self_remove_el.removeEventListener('selfremove', selfRemovingListener);
  };

  const otherListener = () => {
    self_remove_calls.push('other');
  };

  self_remove_el.addEventListener('selfremove', selfRemovingListener);
  self_remove_el.addEventListener('selfremove', otherListener);

  // First dispatch - selfRemovingListener should fire and remove itself
  self_remove_el.dispatchEvent(new Event('selfremove'));
  testing.expectEqual('self', self_remove_calls[0]);
  testing.expectEqual('other', self_remove_calls[1]);
  testing.expectEqual(2, self_remove_calls.length);

  // Second dispatch - only otherListener should fire
  self_remove_el.dispatchEvent(new Event('selfremove'));
  testing.expectEqual('other', self_remove_calls[2]);
  testing.expectEqual(3, self_remove_calls.length);
</script>

<div id=multi_remove_test></div>
<script id=removeMultipleListenersDuringDispatch>
  // Test removing multiple listeners during dispatch (stress test)
  const multi_el = $('#multi_remove_test');
  let multi_calls = [];

  const listeners = [];
  for (let i = 0; i < 10; i++) {
    const listener = () => {
      multi_calls.push(i);
      // Each even-numbered listener removes the next two listeners
      if (i % 2 === 0 && listeners[i + 1] && listeners[i + 2]) {
        multi_el.removeEventListener('multiremove', listeners[i + 1]);
        multi_el.removeEventListener('multiremove', listeners[i + 2]);
      }
    };
    listeners.push(listener);
    multi_el.addEventListener('multiremove', listener);
  }

  multi_el.dispatchEvent(new Event('multiremove'));

  // Should see: 0 (removes 1,2), 3 (but 1,2 already removed), 4 (removes 5,6), 7 (but 5,6 already removed), 8 (doesn't remove because listeners[10] doesn't exist), 9 (not removed)
  // Expected: 0, 3, 4, 7, 8, 9
  testing.expectEqual(0, multi_calls[0]);
  testing.expectEqual(3, multi_calls[1]);
  testing.expectEqual(4, multi_calls[2]);
  testing.expectEqual(7, multi_calls[3]);
  testing.expectEqual(8, multi_calls[4]);
  testing.expectEqual(9, multi_calls[5]);
  testing.expectEqual(6, multi_calls.length);
</script>

<div id=nested_dispatch_test></div>
<script id=nestedDispatchWithRemoval>
  // Test nested event dispatch with listener removal
  const nested_el = $('#nested_dispatch_test');
  let nested_calls = [];

  const inner1 = () => {
    nested_calls.push('inner1');
  };

  const inner2 = () => {
    nested_calls.push('inner2');
  };

  const outer = () => {
    nested_calls.push('outer-start');
    // Dispatch another event in the middle of handling this one
    nested_el.dispatchEvent(new Event('inner'));
    nested_calls.push('outer-end');
    // Remove a listener after the nested dispatch
    nested_el.removeEventListener('inner', inner2);
  };

  nested_el.addEventListener('outer', outer);
  nested_el.addEventListener('inner', inner1);
  nested_el.addEventListener('inner', inner2);

  nested_el.dispatchEvent(new Event('outer'));

  // Should see outer-start, then both inner listeners, then outer-end
  testing.expectEqual('outer-start', nested_calls[0]);
  testing.expectEqual('inner1', nested_calls[1]);
  testing.expectEqual('inner2', nested_calls[2]);
  testing.expectEqual('outer-end', nested_calls[3]);

  // Dispatch inner again - inner2 should be gone
  nested_el.dispatchEvent(new Event('inner'));
  testing.expectEqual('inner1', nested_calls[4]);
  testing.expectEqual(5, nested_calls.length);
</script>

<div id="content"><p id=para></p></div>
<script id=event_target>
  {
    testing.expectEqual('[object EventTarget]', new EventTarget().toString());

    let content = $('#content');
    let para = $('#para');

    var nb = 0;
    var evt;
    var phase;
    var cur;

    function reset() {
      nb = 0;
      evt = undefined;
      phase = undefined;
      cur = undefined;
    }

    function cbk(event) {
      evt = event;
      phase = event.eventPhase;
      cur = event.currentTarget;
      nb++;
    }

    content.addEventListener('basic', cbk);
    content.dispatchEvent(new Event('basic'));
    testing.expectEqual(1, nb);
    testing.expectEqual(true, evt instanceof Event);
    testing.expectEqual('basic', evt.type);
    testing.expectEqual(2, phase);
    testing.expectEqual('content', cur.getAttribute('id'));

    reset();
    para.dispatchEvent(new Event('basic'))

    // handler is not called, no capture, not the targeno bubbling
    testing.expectEqual(0, nb);
    testing.expectEqual(undefined, evt);

    reset();
    content.addEventListener('basic', cbk);
    content.dispatchEvent(new Event('basic'))
    testing.expectEqual(1, nb);

    reset();
    content.addEventListener('basic', cbk, true);
    content.dispatchEvent(new Event('basic'));
    testing.expectEqual(2, nb);

    reset()
    content.removeEventListener('basic', cbk);
    content.dispatchEvent(new Event('basic'));
    testing.expectEqual(1, nb);

    reset();
    content.removeEventListener('basic', cbk, {capture: true});
    content.dispatchEvent(new Event('basic'));
    testing.expectEqual(0, nb);

    reset();
    content.addEventListener('capture', cbk, true);
    content.dispatchEvent(new Event('capture'));
    testing.expectEqual(1, nb);
    testing.expectEqual(true, evt instanceof Event);
    testing.expectEqual('capture', evt.type);
    testing.expectEqual(2, phase);
    testing.expectEqual('content', cur.getAttribute('id'));

    reset();
    para.dispatchEvent(new Event('capture'));
    testing.expectEqual(1, nb);
    testing.expectEqual(true, evt instanceof Event);
    testing.expectEqual('capture', evt.type);
    testing.expectEqual(1, phase);
    testing.expectEqual('content', cur.getAttribute('id'));

    reset();
    content.addEventListener('bubbles', cbk);
    content.dispatchEvent(new Event('bubbles', {bubbles: true}));
    testing.expectEqual(1, nb);
    testing.expectEqual(true, evt instanceof Event);
    testing.expectEqual('bubbles', evt.type);
    testing.expectEqual(2, phase);
    testing.expectEqual('content', cur.getAttribute('id'));

    reset();
    para.dispatchEvent(new Event('bubbles', {bubbles: true}));
    testing.expectEqual(1, nb);
    testing.expectEqual(true, evt instanceof Event);
    testing.expectEqual('bubbles', evt.type);
    testing.expectEqual(3, phase);
    testing.expectEqual('content', cur.getAttribute('id'));


    const obj1 = {
      calls: 0,
      handleEvent: function() { this.calls += 1 }
    };
    content.addEventListener('he', obj1);
    content.dispatchEvent(new Event('he'));
    testing.expectEqual(1, obj1.calls);

    content.removeEventListener('he', obj1);
    content.dispatchEvent(new Event('he'));
    testing.expectEqual(1, obj1.calls);

    // doesn't crash on null receiver
    content.addEventListener('he2', null);
    content.dispatchEvent(new Event('he2'));
  }
</script>
